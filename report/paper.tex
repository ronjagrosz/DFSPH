\title{\vspace{-2cm} \LARGE Divergence-Free Smoothed Particle Hydrodynamics \\ \large Advanced Simulation and Visualization of Fluids in Computer Graphics}

\author{\begin{tabular}{ccc}
    Isabell Jansson\thanks{isaja187@student.liu.se} & Ronja Grosz\thanks{rongr946@student.liu.se}  & Jonathan Bosson\thanks{jonbo665@student.liu.se}
\end{tabular}}

\date{\today}

\documentclass[11pt, twocolumn]{article}

% Our packages
\usepackage{graphicx}   % Images
\usepackage{amsmath}    % Math
\usepackage{amssymb}    % Math
\usepackage{listings}   % To write code in latex
\usepackage{color}      % Custom colors
\usepackage{abstract}   % Onecolabstract, saythanks
\usepackage[margin=1.2in]{geometry}

\usepackage{bm}
\newcommand{\vect}[1]{\bm{#1}} % bold vector

\setlength{\columnsep}{20px} % Length between twocolumn
 
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    literate={\ \ }{{\ }}1
}

\lstset{style=mystyle}
% END our packages

\begin{document}
\twocolumn[
\maketitle

\begin{onecolabstract}
    \noindent This is the paper's abstract \ldots
    \vspace{1em}\\{\bf Index Terms:} Divergence-free, SPH, divergence correction, density correction.\vspace{1em}
\end{onecolabstract}
]
\saythanks

\section{Introduction}
    %explain the context of the work:
	%What exactly is the problem?
	%What have you created?
    Smoothed particle hydrodynamics, \textit{SPH}, is a method that was first implemented in 1977 for astrophysical simulations by Gingold et al.~\cite{firstSPH}.
    Since then SPH has become a popular method for complex fluid simulations.
    SPH is a mesh-free Lagrangian method where the fluid is split into discrete sets defined as particles, which move in space and change physical properties as time progresses.
    % More about Lagrangian and maybe navier stokes?
    
    % We used this article
    In this paper we are going to introduce the results from reproducing the divergence-free smoothed particle hydrodynamics method presented by Bender et al.~\cite{bender}.
    It is a method which corrects the divergence error, aiming for a divergence-free velocity field which is needed for an incompressible fluid.
    For the solution to be divergence-free the density has to be constant over time.
    
    % Write about other solutions? Why is this solution the BEST!!?

\section{Background and Related Work}
    %What have people done before?
	%When addressing this problem, when addressing similar problems
    %What have you done that makes you approach different?

    % Bridson
    ~\cite{bridson}.

    % Write about Benders article


\section{Method}
%What have you done?
%How did you do it?
%Why did you do it that way?
%May want to mention why you *didn’t* do it in some 
%other possible way
%Clear enough that you could hand the report to another student and they could reproduce the work!
%Probably no need to mention programming language etc

\begin{lstlisting}[language=C++, mathescape=true, escapeinside={(*}{*)}]
function performFluidSimulation
    for all particles $i$ do //Init neighbourhoods
        find neighbourhoods $N_i(0)$
    for all particles $i$ do //Init $\color{codegreen}\rho_i$ and $\color{codegreen}\alpha_i$
        compute densities $\rho_i(0)$
        compute factors $\alpha_i(0)$
    while (t < $t_{max}$) do //Start simulation loop
        adapt time step $\Delta{t}$ 
        for all particles $i$ do //Predict velocities $\color{codegreen}\mathbf{v}_i^*$
            $\mathbf{v}_i = \mathbf{v}_i + \Delta{t}\mathbf{F}_g/m_i$
        correctDensityError($\alpha, \mathbf{v}_i$) //Fulfill $\color{codegreen}\rho^* - \rho_0 = 0$
        for all particles $i$ do //Update positions
            $x_i(t + \Delta{t}) = x_i(t) + \Delta{t}\mathbf{v}_i^*$
        for all particles $i$ do //Update neighbourhoods
            find neighbourhoods $N_i(t + \Delta{t})$
        for all particles $i$ do //Update $\color{codegreen}\rho_i$ and $\color{codegreen}\alpha_i$ 
            compute densities $\rho_i(0)$
            compute factors $\alpha_i(0)$
        correctDivergenceError($\alpha, \mathbf{v}^*$) //Fulfill $\color{codegreen}\frac{D\rho}{Dt} = 0$
\end{lstlisting}

\subsection{Neighbourhood search}
    Since SPH only considers a finite amount of neighbouring particles it is important to keep track of every particles neighbours.
    Searching through all particles for neighbours within the cutoff distance $H$ for every particle is inefficient and takes $\mathcal{O}({N^2})$ time.
    The cutoff distance $H$ is the kernels smoothing radius.
    To make this faster a cell list was implemented.
    A cell list is a data structure that is divided into cells that have a length larger or equals to the cutoff distance $H$.
    Each cell spans on a surface in space.
    A particle belongs to a cell if it is inside the space the cell occupy.
    When finding the neighbour of particle $i$, only the neighbouring cells have to be searched for particles within the cutoff distance, see figure~\ref{fig:cellList}.
    
    \begin{figure}[h!]\centering
    \begin{centering}
    \includegraphics[width=0.7\linewidth]{img/CellList.png}
    \caption{Finding the neighbours for the filled in particle $i$ by looking through all neighbouring cells, including its own cell, for particles within the cutoff distance $H$}
    \label{fig:cellList}
    \end{centering}
    \end{figure}

    The cell list is implemented by using a four dimensional vector where the first three dimensions are for the x, y and z coordinates and the fourth dimension is for storing the particles belonging to the cell.
    The amount of cells are decided by dividing the scene into cells of length $H$.
    The particles are then assigned to a cell by finding the cell's coordinates that it belongs to according to Equation ~\ref{eq:assignCell}, where $\vect{x}$ is the position of the particle and $\vect{s}_min$ is the lowest position of the scene space.
    If the particle moves out of its cell it is reassigned to the new cell it is inside.

    \begin{equation} \label{eq:assignCell}
        \frac{\lceil{\vect{x} - \vect{s}_{min}}\rceil}{H}
    \end{equation}

% Should be mentioned early since it is used in mostly of the algorithms
\subsection{Kernel}
    A kernel function is used to simulate how particle-particle interactions decrease with the distance between the current particle and its neighbours. In SPH simulations this is an approximation of the Gaussian kernel function. Different kernels have been tested in previous works i.e. the poly6 kernel, the spiky kernel and the cubic spline kernel. According to Bender et. al.~\cite{bender} the cubic spline kernel presented by Monaghan~\cite{monaghan} was used. The kernel is described by Equation~\ref{eq:kernel}, where $q(x)=\frac{\left \| x \right \|}{h}$, $x$ is the distance between the current particle and a neighbour particle and $h$ is the support radius for the kernel. Particles further away than the support radius will not affect the current particle.   

    \begin{equation} \label{eq:kernel}
        W_h(q(x)) =  \frac{1}{\pi h^3} \left\{\begin{matrix}
        1 - \frac{3}{2}q^2 + \frac{3}{4}q^3 & 0 \leqslant q < 1 \\ 
        \\
        \frac{1}{4}(2-q)^3 & 1 \leqslant q < 2\\ 
        \\
        0 & q \geqslant 2
      \end{matrix}\right.
    \end{equation}

    The algorithm does also require the kernel gradient. To reduce the computational effort and memory requirements Bender et. al.~\cite{bender} introduce a scalar function $g(q) = \frac{\partial W_h}{\partial q} \cdot \frac{1}{h \left \| x \right \|}$. The gradient kernel is then calculated by $\partial W_h(q(x)) = x \cdot g(x)$. The gradient kernel is described by Equation ~\ref{eq:gradKernel}. 

    \begin{equation} \label{eq:gradKernel}
        \partial W_h(q(x)) =  x \cdot \frac{1}{h \left \| x \right \|} \cdot \frac{1}{\pi h^3} \left\{\begin{matrix}
        - 3q + \frac{9}{4}q^2 & 0 \leqslant q < 1 \\ 
        \\
        - \frac{3}{4}(2-q)^2 & 1 \leqslant q < 2\\ 
        \\
        0 & q \geqslant 2
      \end{matrix}\right.
    \end{equation}
    % maybe specify x here as well 

    It is important to use the same kernel function for both $W_h$ and $\nabla W_h$ to get the prediction and the correction step to be compatible to each other.


\subsection{Divergence-Free solver}


\iffalse
\begin{lstlisting}[language=C++, mathescape=true, escapeinside={(*}{*)}]
function correctDivergenceError
    for all particles $i$ do
        calculateDensityChange $\frac{Dp}{Dt}_i$
    for all particles $i$ do //Scale $\color{codegreen}a_i$
        $a_i = \frac{a_i}{\Delta t}$
    while (t < $t_{max}$) do //Start simulation loop
        adapt time step $\Delta{t}$ 
        for all particles $i$ do //Predict velocities $\color{codegreen}\mathbf{v}_i^*$
            $\mathbf{v}_i = \mathbf{v}_i + \Delta{t}\mathbf{F}_i^{adv}/m_i$
        correctDensityError($\alpha, \mathbf{v}_i$) //Fulfill $\color{codegreen}\rho^* - \rho_0 = 0$
        for all particles $i$ do //Update positions
            $x_i(t + \Delta{t}) = x_i(t) + \Delta{t}\mathbf{v}_i^*$
        for all particles $i$ do //Update neighbourhoods
            find neighbourhoods $N_i(t + \Delta{t})$
        for all particles $i$ do //Update $\color{codegreen}\rho_i$ and $\color{codegreen}\alpha_i$ 
            compute densities $\rho_i(0)$
            compute factors $\alpha_i(0)$
        correctDivergenceError($\alpha, \mathbf{v}^*$) //Fulfill $\color{codegreen}\frac{D\rho}{Dt} = 0$
\end{lstlisting}
\fi

The divergence-free solver ensures the fluid to be free of density change over time by enforcing $\frac{D\rho}{Dt} = 0$, which is equivalent to the Navier-Stokes divergence free condition given in equation %\ref{eq:navier}.

The solver will ensure that the divergence error is of an acceptable level defined by the user. The divergence error is suppressed by a combined symmetric pressure force $\vect{F_{j\leftarrow i}^p} $ over all particle $i$'s neighbours $j$, that is applied to the predicted velocity of particle $i$. The pressure force is determined by 

\begin{equation} \label{eq:pressure}
\vect{F_i^p} = -\frac{m_i}{\rho_i}\nabla \vect{p_i},
\end{equation}

where the pressure gradient can be solved using the SPH formulation proposed by Ihmsen et al.~\cite{ihmsen}.

\begin{equation} \label{eq:dpdt}
\frac{D\rho_i}{Dt} = \sum_j m_j (\vect{v_i} - \vect{v_j})\nabla \vect{W_{ij}}
\end{equation}

\begin{equation} \label{eq:kappa}
\nabla \vect{p_i} = \kappa_i^v \nabla \rho_i = \kappa_i^v \sum_j m_j \nabla \vect{W_{ij}}
\end{equation}

Equation \ref{eq:dpdt} defines how the density change is computed and \ref{eq:kappa} computes the pressure gradient with the help of the stiffness parameter $\kappa_i^v$, where 

\begin{equation}
\kappa_i^v = \frac{D\rho}{Dt} \cdot \frac{\rho_i}{\Delta t \cdot \alpha_i}
\end{equation}

and $\alpha_i$ is the scaling factor only dependant on the position explained in section \ref{section:alpha}. The stiffness parameters needs to be determined iteratively since neighboring particles depend on each other.
The velocity of particle $i$ is thus changed to:

\begin{equation} \label{eq:pressuretotal}
\vect{v_i^*}(t) = \vect{v_i^*}(t) - \Delta t \sum_j m_j (\frac{\kappa_i^v}{\rho_i} \cdot \frac{\kappa_j^v}{\rho_i}) \nabla \vect{W_{ij}}
\end{equation}

After the symmetric pressure force has been applied to the new velocity should the density change in equation \ref{eq:dpdt} be equal or close to zero. If the error is too large will the process be iterated until desired result have been achieved.

\subsection{Density solver}

\subsection{Navier-stokes}
% Write about non pressure forces, velocity osv..?
\subsection{Adapted time step}

% CFL condition, explain why its necessary and how its assured that each rendered frame has the same time step.
In order to assure a stable simulation it is necessary to adapt the time step depending on the motion. 
The quicker the particles move the smaller time steps are taken such that the numerical 
error of the explicit time integration is negligible. For this is a condition proposed by 
Courant$-$Friedrichs$-$Lewy used often refered as the CFL-condition show in equation \ref{eq:cfl}. 
The time step $\Delta t$ is equal to a fraction of the particle's diameter $d$ divided by 
the maximum velocity $\vect{V_{max}}$ in the scene.

\begin{equation}\label{eq:cfl}
\Delta t \leq \frac{0.4 \cdot d}{\vect{V_{max}}}
\end{equation}

Each rendered frame however have a constant time step in order to ensure no speed change in the playback of the rendered video. 
This is decided from the user side as a desired fps parameter. 
This means that the simulation loop can iterate multiple times within each frame adaptively depending on the maximum velocity.

\subsection{Density and alpha factors} \label{section:alpha}
\subsection{Screen space fluid rendering}

\section{Implementation}
%Details of how it was done
%What hardware
%What software
%Why did you do it that way?
%What limitations, if any, did this present?
%*No code*!!!!!
 
    % Talk about what we used for plugins, computers etc maybe or should this be in method?

\section{Results}
%What is the end product:
%What does it look like?
%How does one control and interact with it?
%How quick is it?
%What limitations does it have?
%Be self-critical and honest about it - or I will be



\section{Conclusions and Future Work}
%Based on the results and evaluation
%Say what you’ve done right... ...and what you’ve done wrong! - be honest!
%Suggest some possible ways that the work could have been done better
%Suggest some ways that it could be extended and improved by adding more effort

% Use ghost-SPH or similar

\bibliographystyle{ieeetr}
\bibliography{./refs}

\end{document}
